---
title: 2020-08-31-git进阶
mathjax: true
date: 2020-08-31 16:41:49
tags: git
top:
categories: git
description: git的进阶使用总结
---

### 前言

之前总结过git的一些基本命令，后来使用了更多git，写博客用于记录。不断更新 ，在实践中总结git知识点。



### git status 和 git diff

在对文件进行修改之后，可以用 `git status` 查看结果，可以让我们时刻掌握仓库当前的状态

<img src="https://i.loli.net/2020/08/31/fTmxaAeZG1iSCLd.png" alt="image-20200831180231338" style="zoom:67%;" />

可以看到在`modified`部分，可以看到有四个文件被修改了，**但是还没有进行提交（`commit`）修改**

而下半部分的`untracked files`表示的是**之前从未提交到仓库分支**的文件（一个markd文件，一个照片） 



上述只是看到被修改的文件，但如果能看看具体修改了什么内容就好了，`git diff` 可以实现这个功能

<img src="https://i.loli.net/2020/08/31/nVd3hGKLJy6f7zH.png" alt="image-20200831194816455"  />

可以看到修改的详细细节（红色为修改前的内容，绿色为修改后的内容）。向下箭头可以下拉文本，`q`退出查看 （quit）



这样就可以放心的添加（add）到仓库的暂存区，并提交（commit）到仓库分支

```bash
git add .
git commit -m 20/8/31/commit1
```



#### 小结

- 要随时掌握工作区的状态，使用`git status`命令。
- 如果`git status`告诉你有文件被修改过，用`git diff`可以查看修改内容。



### 版本回退

每当文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为`commit`。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个`commit`恢复，然后继续工作，而不是把几个月的工作成果全部丢失。

在Git中，我们用`git log`命令查看：

<img src="https://i.loli.net/2020/08/31/4lC7ufP6ZmbUvWT.png" alt="image-20200831233324006" style="zoom:80%;" />

`git log`命令显示从最近到最远的提交日志，每一次`commit`很详细

可以加上`--pretty=oneline`参数，来简化显示。推荐使用

<img src="https://i.loli.net/2020/08/31/xNXAn7Pt8rT2mcE.png" alt="image-20200831233340202" style="zoom:80%;" />

其中前面编号类似`012214236e...`的是`commit id`（版本号），是一个`SHA1`计算出来的一个非常大的数字，用十六进制表示

每个人的编号不一样，因为Git是分布式的版本控制系统，多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。

> [Hash在线计算、md5计算、sha1计算、sha256计算、sha512计算](https://1024tools.com/hash)

#### 回退到历史版本

这样我们就可以进行回退操作

首先，Git必须知道当前版本是哪个版本。

在Git中，用`HEAD`表示当前版本，也就是最新的提交`012214236e...`，上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。

我们可以使用`git reset`命令：

```bash
git reset --hard HEAD^ #回退到上一版本
```

![image-20200831233416378](https://i.loli.net/2020/08/31/k37ptdoMJxGcufR.png)

结果显示出现在是`ca41b0a`，也就是上一次`commit`的版本。我们成功回退版本！

当我们再查看日志的时候，发现已经没有`20/8/31/commit1`版本了

![image-20200831233446124](https://i.loli.net/2020/08/31/xWIlbtTwazUJNdO.png)

------

#### 还原到最新版本

如果想要再还原到`20/8/31/commit1`版本呢？

也是可以的，只要**`上面的命令行窗口还没有被关掉`**，就可以顺着往上找，找到那个`20/8/31/commit1`版本的`commit id`是`012214236e...`，于是就可以指定回到未来的某个版本：

```bash
git reset --hard 0221423
```

![image-20200831233507305](https://i.loli.net/2020/08/31/9pK7UsnRrv1loSD.png)

版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。

这样就实现了还原到最后`commit`版本

Git的版本回退速度非常快，因为Git在内部有个指向当前版本的`HEAD`指针，当你回退版本的时候，Git仅仅是把HEAD从指向历史版本，再将工作区的文件更新即可

如果回退到了某个版本，关掉了命令行窗口，后悔想恢复到新版本但是找不到新版本的`commit id`怎么办？

在Git中，总是有后悔药可以吃的。Git提供了一个命令`git reflog`用来记录你的每一次命令：

![image-20200901000008019](https://i.loli.net/2020/09/01/Ly4MDnv6WAEwQlV.png)

知道`commit_id`，还原版本就十分滴完美！

> **注！！！**
>
> 如果从历史版本回到最后的版本，也只能还原到最后`commit`后的版本。
>
> 我才开始`commit`了版本A，之后又写了一部分内容 B(未`commit`)。还原到了A-1版本，之后又想还原到A+B版本，操作完之后发现还原后的没有B部分，也就是我只能还原到A。
>
> 原因就是我在最后一次`commit`就是A，而写完B之后，没有`commit` ，于是无法还原。 （多多`commit`，
>
> ，还原需谨慎。我是真的折腾）:sob:



#### 小结

- `HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。 （commit_id也写成HEAD^）
- 穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。
- 要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。

#### 参考

> [常用git命令清单-阮一峰](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)
>
> [读懂diff-阮一峰](http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)
>
> [git教程-廖雪峰](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)
>
> [git教程-菜鸟教程](http://www.runoob.com/git/git-install-setup.html)
>
> [gitbook](https://git-scm.com/book/zh/v2)
>
> [Git Community Book](http://gitbook.liuhui998.com/index.)
>
> [从只会git add .的菜鸟到掌握git基本功能](https://juejin.im/post/6844903586023866375)



### 工作区和暂存区

#### 工作区（Working Directory）

就是在电脑里能看到的目录，比如我的`mynlog`文件夹就是一个工作区：

<img src="https://i.loli.net/2020/09/01/lp9hvTzLtVuMPG5.png" alt="image-20200901000937480" style="zoom:80%;" />



#### 版本库（Repository）

也就是本地仓库

工作区有一个隐藏目录`.git`，这个不算工作区，而是Git的版本库。（选择`隐藏文件可见`就可以看到）

Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫`index`）的暂存区，还有Git为我们自动创建的第一个分支`master`，以及指向`master`的一个指针叫`HEAD`。

<img src="https://i.loli.net/2020/09/01/wBe5iWuajDJKxdV.png" alt="image-20200901001300425" style="zoom:80%;" />

<img src="https://i.loli.net/2020/09/01/KywEFn2dtMJeBkq.png" alt="image-20200901001406385" style="zoom:80%;" />

前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：

第一步是用`git add`把文件添加进去，实际上就是把文件修改添加到暂存区(`index`)；

第二步是用`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支(`master`)。

因为我们创建Git版本库时，Git自动为我们创建了唯一一个`master`分支，所以，现在，`git commit`就是往`master`分支上提交更改。

你可以简单理解为，**需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。** 也就是可以多次`git add .` ,之后再一次性`git commit` 

我对文件进行修改之后，`git status` 显示如下：

![image-20200901003431025](https://i.loli.net/2020/09/01/qZ4JcAzCrBOQng5.png)

这是对文件进行了修改，但是未添加（add）到暂存区和提交（commit）到仓库分支。 并且出现了之前从未提交的文件（四张png图片）



然后`git add .`,再查看目前的状态 `git status`

![image-20200901003844459](https://i.loli.net/2020/09/01/leMQO9F83N5DxUq.png)

出现了绿色的`new file`字样和`modified`，代表已添加到缓存区。

现在，暂存区的状态就变成这样了（原文是添加的readme和LICENSE文件）：

![image-20200901003951252](https://i.loli.net/2020/09/01/MHQiJkB674jcAE5.png)

所以，`git add`命令实际上就是把要提交的所有修改放到暂存区（index），然后，执行`git commit`就可以一次性把暂存区的所有修改提交到分支。

![image-20200901004202394](https://i.loli.net/2020/09/01/1uzidT9knarwNMU.png)

这时候再 `git status`，则是干净的

现在版本库变成了这样，暂存区就没有任何内容了：

![git-stage-after-commit](https://i.loli.net/2020/09/01/kCXlv3FiurZNbIO.jpg)

#### 小结

了解工作区和暂存区的概念，并通过例子加强`git status`  、`git add`、`git commit`的理解

如果不用`git add`到暂存区，那就不会加入到`commit`中。也就是说`commit`只会提交暂存区里的内容



